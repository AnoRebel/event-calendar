// Calendar Service Worker for offline support and caching

// const CACHE_NAME = 'event-calendar-v1' // Reserved for future use
const STATIC_CACHE = "static-v1"
const DYNAMIC_CACHE = "dynamic-v1"

// Files to cache for offline use
const STATIC_FILES = [
  "/",
  "/manifest.json",
  "/favicon.ico",
  "*.js",
  "*.css",
  // Add your compiled CSS and JS files here
  // These will be generated by your build process
]

class AssetPathResolver {
  fallbackPaths = []
  cdnPaths = []

  addFallbackPath(path) {
    this.fallbackPaths.push(path.endsWith("/") ? path : path + "/")
  }

  addCDNPath(path) {
    this.cdnPaths.push(path.endsWith("/") ? path : path + "/")
  }

  async resolveAsset(relativePath) {
    const paths = [
      ...this.cdnPaths.map(base => base + relativePath),
      relativePath,
      ...this.fallbackPaths.map(base => base + relativePath),
    ]

    for (const path of paths) {
      try {
        const response = await fetch(path)
        if (response.ok) {
          console.log(`Resolved ${relativePath} from ${path}`)
          return response
        }
      } catch (error) {
        console.warn(`Failed to load from ${path}:`, error)
      }
    }

    throw new Error(`Could not resolve asset: ${relativePath}`)
  }
}

const pathResolver = new AssetPathResolver()

self.addEventListener("message", event => {
  if (event.data.type === "ADD_FALLBACK_PATH") {
    pathResolver.addFallbackPath(event.data.path)
  }

  if (event.data.type === "ADD_CDN_PATH") {
    pathResolver.addCDNPath(event.data.path)
  }
})

self.addEventListener("fetch", event => {
  const url = new URL(event.request.url)

  if (url.pathname.match(/\.(js|css)$/)) {
    event.respondWith(
      pathResolver.resolveAsset(url.pathname).catch(() => new Response("Asset not found", { status: 404 }))
    )
  }
})

// API endpoints to cache (for future use)
// const CACHEABLE_APIS = [
//   '/api/events',
//   '/api/user/preferences'
// ]

// Install event - cache static assets
self.addEventListener("install", event => {
  console.log("Service Worker: Installing...")

  event.waitUntil(
    caches
      .open(STATIC_CACHE)
      .then(cache => {
        console.log("Service Worker: Caching static files")
        return cache.addAll(STATIC_FILES)
      })
      .then(() => {
        return self.skipWaiting()
      })
      .catch(error => {
        console.error("Service Worker: Error caching static files", error)
      })
  )
})

// Activate event - clean up old caches
self.addEventListener("activate", event => {
  console.log("Service Worker: Activating...")

  event.waitUntil(
    caches
      .keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
              console.log("Service Worker: Deleting old cache", cacheName)
              return caches.delete(cacheName)
            }
          })
        )
      })
      .then(() => {
        return self.clients.claim()
      })
  )
})

// Fetch event - implement caching strategies
self.addEventListener("fetch", event => {
  const { request } = event
  const url = new URL(request.url)

  // Skip non-GET requests
  if (request.method !== "GET") {
    return
  }

  // Handle API requests
  if (url.pathname.startsWith("/api/")) {
    event.respondWith(handleApiRequest(request))
    return
  }

  // Handle static files
  if (STATIC_FILES.some(file => url.pathname === file || url.pathname.endsWith(file))) {
    event.respondWith(handleStaticRequest(request))
    return
  }

  // Handle other requests
  event.respondWith(handleDynamicRequest(request))
})

// Cache-first strategy for static files
async function handleStaticRequest(request) {
  try {
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      return cachedResponse
    }

    const response = await fetch(request)
    if (response.ok) {
      const cache = await caches.open(STATIC_CACHE)
      cache.put(request, response.clone())
    }

    return response
  } catch (error) {
    console.error("Service Worker: Error handling static request", error)
    return new Response("Offline", { status: 503 })
  }
}

// Network-first strategy for API requests with offline fallback
async function handleApiRequest(request) {
  try {
    const response = await fetch(request)

    if (response.ok) {
      // Cache successful API responses
      const cache = await caches.open(DYNAMIC_CACHE)
      cache.put(request, response.clone())
    }

    return response
  } catch (error) {
    console.log("Service Worker: Network failed, trying cache for", request.url)

    // Try to get from cache
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      // Add offline indicator header
      const offlineResponse = cachedResponse.clone()
      offlineResponse.headers.set("X-Served-From", "cache")
      return offlineResponse
    }

    // Return offline fallback for API requests
    if (request.url.includes("/api/events")) {
      return new Response(
        JSON.stringify({
          data: [],
          offline: true,
          message: "Offline mode: showing cached data",
        }),
        {
          status: 200,
          headers: { "Content-Type": "application/json" },
        }
      )
    }

    return new Response("Offline", { status: 503 })
  }
}

// Stale-while-revalidate strategy for dynamic content
async function handleDynamicRequest(request) {
  try {
    const cache = await caches.open(DYNAMIC_CACHE)
    const cachedResponse = await cache.match(request)

    // Start fetch in background
    const fetchPromise = fetch(request)
      .then(response => {
        if (response.ok) {
          cache.put(request, response.clone())
        }
        return response
      })
      .catch(() => null)

    // Return cached version immediately if available
    if (cachedResponse) {
      // Update cache in background
      fetchPromise.catch(() => {}) // Prevent unhandled rejection
      return cachedResponse
    }

    // Otherwise wait for network
    return (await fetchPromise) || new Response("Offline", { status: 503 })
  } catch (error) {
    console.error("Service Worker: Error handling dynamic request", error)
    return new Response("Offline", { status: 503 })
  }
}

// Background sync for offline actions
self.addEventListener("sync", event => {
  console.log("Service Worker: Background sync triggered", event.tag)

  if (event.tag === "sync-events") {
    event.waitUntil(syncOfflineEvents())
  }
})

// Sync offline events when back online
async function syncOfflineEvents() {
  try {
    // Get offline events from IndexedDB (you'd implement this)
    const offlineEvents = await getOfflineEvents()

    for (const event of offlineEvents) {
      try {
        const response = await fetch("/api/events", {
          method: event.method || "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(event.data),
        })

        if (response.ok) {
          // Remove from offline storage
          await removeOfflineEvent(event.id)

          // Notify clients of successful sync
          self.clients.matchAll().then(clients => {
            clients.forEach(client => {
              client.postMessage({
                type: "SYNC_SUCCESS",
                eventId: event.id,
              })
            })
          })
        }
      } catch (error) {
        console.error("Service Worker: Failed to sync event", event.id, error)
      }
    }
  } catch (error) {
    console.error("Service Worker: Error during background sync", error)
  }
}

// Push notification handling
self.addEventListener("push", event => {
  console.log("Service Worker: Push message received")

  let data = {}
  try {
    data = event.data ? event.data.json() : {}
  } catch (error) {
    console.error("Service Worker: Error parsing push data", error)
  }

  const options = {
    title: data.title || "Calendar Notification",
    body: data.body || "You have a calendar update",
    icon: "/favicon.ico",
    badge: "/favicon.ico",
    tag: data.tag || "calendar-notification",
    requireInteraction: data.requireInteraction || false,
    actions: data.actions || [],
    data: data.data || {},
  }

  event.waitUntil(self.registration.showNotification(options.title, options))
})

// Notification click handling
self.addEventListener("notificationclick", event => {
  console.log("Service Worker: Notification clicked", event)

  event.notification.close()

  const urlToOpen = event.notification.data?.url || "/"

  event.waitUntil(
    self.clients.matchAll({ type: "window" }).then(clients => {
      // Check if there's already a window/tab open with the target URL
      for (const client of clients) {
        if (client.url === urlToOpen && "focus" in client) {
          return client.focus()
        }
      }

      // If not, open a new window/tab
      if (self.clients.openWindow) {
        return self.clients.openWindow(urlToOpen)
      }
    })
  )
})

// Message handling from main thread
self.addEventListener("message", event => {
  const { type, data } = event.data

  switch (type) {
    case "SKIP_WAITING":
      self.skipWaiting()
      break

    case "CACHE_EVENT":
      event.waitUntil(cacheOfflineEvent(data))
      break

    case "GET_CACHED_EVENTS":
      event.waitUntil(
        getCachedEvents().then(events => {
          event.ports[0].postMessage({ type: "CACHED_EVENTS", data: events })
        })
      )
      break

    default:
      console.log("Service Worker: Unknown message type", type)
  }
})

// Utility functions for offline storage
async function getOfflineEvents() {
  // Implement IndexedDB operations
  // This is a placeholder - you'd implement proper IndexedDB operations
  return []
}

async function removeOfflineEvent(eventId) {
  // Implement IndexedDB operations
  console.log("Removing offline event:", eventId)
}

async function cacheOfflineEvent(eventData) {
  // Store event in IndexedDB for later sync
  console.log("Caching offline event:", eventData)

  // Register for background sync
  try {
    await self.registration.sync.register("sync-events")
  } catch (error) {
    console.error("Service Worker: Error registering sync", error)
  }
}

async function getCachedEvents() {
  try {
    const cache = await caches.open(DYNAMIC_CACHE)
    const cachedResponse = await cache.match("/api/events")

    if (cachedResponse) {
      const data = await cachedResponse.json()
      return data.data || []
    }

    return []
  } catch (error) {
    console.error("Service Worker: Error getting cached events", error)
    return []
  }
}

// Performance monitoring
self.addEventListener("fetch", event => {
  // Track performance metrics
  const start = performance.now()

  event.respondWith(
    handleRequest(event.request).then(response => {
      const end = performance.now()
      const duration = end - start

      // Log slow requests
      if (duration > 3000) {
        console.warn(`Service Worker: Slow request detected: ${event.request.url} (${duration}ms)`)
      }

      return response
    })
  )
})

// Generic request handler
async function handleRequest(request) {
  const url = new URL(request.url)

  if (url.pathname.startsWith("/api/")) {
    return handleApiRequest(request)
  } else if (STATIC_FILES.some(file => url.pathname.endsWith(file))) {
    return handleStaticRequest(request)
  } else {
    return handleDynamicRequest(request)
  }
}
